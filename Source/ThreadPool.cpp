////////////////////////////////////////////////////////////////
// секция PCH
////////////////////////////////////////////////////////////////
#include "PCH.h"
////////////////////////////////////////////////////////////////
// секция заголовочного файла
////////////////////////////////////////////////////////////////
#include "ThreadPool.h"
////////////////////////////////////////////////////////////////
// секция компиляция файла
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// секция форвард-декларации
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// секция для исключений
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// секция для остального
////////////////////////////////////////////////////////////////



	//==============================================================
	//==============================================================

	Thread::Thread() {

		_working_.test_and_set();

		// создаём новый поток
		_thread_ = std::thread(&Thread::loop, this);

	}

	//==============================================================
	//==============================================================

	Thread::~Thread() {

		if (_thread_.joinable()) {

			// ждём, когда поток закончит работу
			wait();

			_working_.clear();
		}
	}

	//==============================================================
	//==============================================================

	//void Thread::addTask(std::function<void(void)> task) { 

	// блокируем список задач и добавляем новую задачу
	//	std::unique_lock<std::mutex> lock(_mutexQueue_);
	//	_taskQueue1.push(task);

	// уведомляем что была добавлена задача
	//	_condition_.notify_one();
	//}
	//void Thread::addTask(std::shared_ptr<CTask> task) { 

	// блокируем список задач и добавляем новую задачу
	//	std::unique_lock<std::mutex> lock(_mutexQueue_);
	//	_taskQueue.push(task);

	// уведомляем что была добавлена задача
	//	_condition_.notify_one();
	//}
	void Thread::addTask(CTask* task) {

		// блокируем список задач и добавляем новую задачу
		std::unique_lock<std::mutex> lock(_mutexQueue_);
		_taskQueue1.push(task);

		// уведомляем что была добавлена задача
		_condition_.notify_one();
	}
	//==============================================================
	//==============================================================

	void Thread::wait() {

		// блокировать поток, пока не будет уведомления (_condition_) { и пока список задач (_taskQueue_) { не будет пустой
		std::unique_lock<std::mutex> lock(_mutexQueue_);

		_condition_.wait(lock, [this]() {  return _taskQueue1.empty(); });

	}

	//==============================================================
	//==============================================================

	void Thread::loop() {

		// цикл работает до тех пор пока _working_ не false
		while (_working_.test_and_set()) {

			// 
			{
				// блокируем поток до тех пор, 
				// пока нас не уведомят (_condition_) { и пока список задач (_taskQueue_) { не пустой
				std::unique_lock<std::mutex> lock(_mutexQueue_);
				//_condition_.wait(lock, [this] { return !_taskQueue.empty(); });
				_condition_.wait(lock, [this] { return !_taskQueue1.empty(); });

			}

			// выолняем задачу
			_taskQueue1.front()->execute();

			//
			{
				// блокируем список задач, чтобы убрать уже выолненную задачу
				std::lock_guard<std::mutex> lock(_mutexQueue_);
				_taskQueue1.front()->complete();
				_taskQueue1.pop();

				// уведомляем что задача выполнена
				_condition_.notify_one();


			}

		} // while

	}

	//==============================================================
	//==============================================================
		

	ThreadManager::ThreadManager() :
		_threadCountMax_(std::thread::hardware_concurrency()) {

		// создаём новые потоки и добавляем их в список
		for (unsigned i = 0; i < _threadCountMax_; ++i) {

			_threadList_.push_back(std::make_unique<Thread>());
		}
	}

	//==============================================================
	//==============================================================

	//void ThreadManager::addTask(std::function<void(void)> task) { 
	//	_threadList_[1]->addTask(task);
	//}

	//void ThreadManager::addTask(std::shared_ptr<CTask> task, int id) {
	//	_threadList_[id]->addTask(task);
	//}
	void ThreadManager::addTask(CTask* task, int id) {
		_threadList_[id]->addTask(task);
	}
	void ThreadManager::wait(void) {

		for (int i = 0; i < 8; ++i) {

			_threadList_[i]->wait();
		}
	}
	//==============================================================
	//==============================================================
