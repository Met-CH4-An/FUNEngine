#ifndef THREAD_POOL__H
#define THREAD_POOL__H
////////////////////////////////////////////////////////////////
// секция компиляция файла
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// секция родительского класса
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// секция форвард-декларации
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// секция для остального
////////////////////////////////////////////////////////////////
#include <functional>
#include <thread>
#include <mutex>
#include <queue>
#include <atomic>
#include <future>
#include <memory>



	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	class CTask {

	public:

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		void complete() {
			_complete_.clear();
		}

		bool isComplete(void) {
			return _complete_.test_and_set() ? false : true;
		}

		virtual void execute(void) = 0;

		CTask() {

			_complete_.test_and_set();
		}
	private:
			
		std::atomic_flag _complete_ = ATOMIC_FLAG_INIT;

	};



	class Thread {

	public:

		////////////////////////////////////////////////////////////////
		/// \brief Конструктор.
		///
		/// Конструктор запускает новый поток.
		///
		/// \param		void	Ничего не принимает.
		/// \return		void	Ничего не возвращает.
		////////////////////////////////////////////////////////////////
		Thread();

		////////////////////////////////////////////////////////////////
		/// \brief Деструктор
		///
		/// Если поток еще в работе, деструктор ждёт завершения всех задач
		/// и устанавливает флаг _working_ в false.
		///
		/// \param		void	Ничего не принимает.
		/// \return		void	Ничего не возвращает.
		////////////////////////////////////////////////////////////////
		~Thread();

		////////////////////////////////////////////////////////////////
		/// \brief Добавить новую задачу.
		///
		/// Функция добавляет в список задач новую задачу и уведомляет об этом.
		///
		/// \param		taskFunc	Функция с новой задачей.
		/// \return		void		Ничего не возвращает.
		////////////////////////////////////////////////////////////////
		//void addTask(std::function<void(void)> taskFunc);
		//void addTask(std::shared_ptr<CTask> task);
		void addTask(CTask* task);
		////////////////////////////////////////////////////////////////
		/// \brief Ожидание завершения всех задач.
		///
		/// Функция блокирует поток где был вызван wait, пока не завершатся все
		/// задачи в потоке.
		///
		/// \param		void	Ничего не принимает.
		/// \return		void	Ничего не возвращает.
		////////////////////////////////////////////////////////////////
		void wait();

	private:

		////////////////////////////////////////////////////////////////
		/// \brief Цикл работы потока.
		///
		/// Цикл обеспечивает работу потока. Цикл закончен - поток умер.
		///
		/// \param		void	Ничего не принимает.
		/// \return		void	Ничего не возвращает.
		////////////////////////////////////////////////////////////////
		void loop(void);

	private:

		std::thread								_thread_;			///< Поток
																	//std::queue<std::function<void(void) {>>		_taskQueue_;		///< Очередь с задачами для потока.
																	//std::queue<std::packaged_task<bool(void) {>>	_taskQueue_;		///< Очередь с задачами для потока.
																	//std::queue<std::shared_ptr<CTask>>		_taskQueue;
		std::queue<CTask*>						_taskQueue1;
		std::mutex								_mutexQueue_;		///< Мьютекс для очереди с заданиями.
		std::condition_variable					_condition_;		///<
		std::atomic_flag						_working_;			///< Флаг, указывающий что поток работает.

	}; // class Thread



	class ThreadManager {

		// Treads.cpp
	public:

		uint32_t getMaxThreads(void) {
			return _threadCountMax_;
		}

		////////////////////////////////////////////////////////////////
		/// \brief Конструктор.
		///
		/// Устанавливает макисмальное количество потоков для использования.
		///
		/// \param		void		Ничего не принимает.
		/// \return		void		Ничего не возвращает.
		////////////////////////////////////////////////////////////////
		ThreadManager();

		////////////////////////////////////////////////////////////////
		/// \brief Добавить задачу.
		///
		/// Функция выбирает поток и добавляет в него новую задачу.
		///
		/// \param		taskFunc	Задачу для выполнения.
		/// \return		void		Ничего не возвращает.
		////////////////////////////////////////////////////////////////
		//void addTask(std::function<void(void)> taskFunc);
		//void addTask(std::shared_ptr<CTask> task, int id);
		void addTask(CTask* task, int id = 0);
		void wait(void);
	public:

		const unsigned							_threadCountMax_;	///< Максимальное количество потоков.
		std::vector<std::unique_ptr<Thread>>	_threadList_;		///< Список потоков.

	}; // class ThreadManager



#include "ThreadPool.hpp"

#endif // THREAD_POOL__H