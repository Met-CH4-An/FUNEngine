#ifndef DATA_BUFFER__H
#define DATA_BUFFER__H
////////////////////////////////////////////////////////////////
// секция компиляция файла
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// секция родительского класса
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// секция форвард-декларации
////////////////////////////////////////////////////////////////
#include "CommonRenderInterface.h"
#include "../Common\FCommon.h"
////////////////////////////////////////////////////////////////
// секция для остального
////////////////////////////////////////////////////////////////

namespace FE {

	namespace CRI {

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		/*!	\brief Информация для обновления буфера.
		*/
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		struct CRI_DATA_BUFFER_UPDATE_INFO {

			void*			m_Data = nullptr;		///< Данные.
			uint32_t		m_Offset = 0;			///< Смещение, по которому данные будут записываться.
			size_t			m_Size = 0;				///< Размер данных.
		
		}; // struct CRI_DATA_BUFFER_UPDATE_INFO



		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		/*!	\brief Информация для создания буфера данных.
		*/
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		struct CRI_DATA_BUFFER_CREATE_INFO {

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			/*!	\brief Использование буфера.
			*/
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			enum class USAGE {
				UNKNOWN,		///< 
				VERTEX,			///< Буфер для вертексных дданых.
				INDEX,			///< Буфер для индексных данных.
				UNIFORM,		///< Буффер для юниформ.
			}; // enum class USAGE

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			/*!	\brief Хранение данных в буфере.
			*/
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			enum class STORAGE {
				UNKNOWN,
				HOST,
				DEVICE
			}; // enum class STORAGE

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			/*!	\brief Использование буфера.
			*/
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			enum class PROPS {
				UNKNOWN			= 0x0000000,
				STORAGE			= 0x0000001,
				TRANSFER		= 0x0000002
			}; // enum class PROPS

			USAGE								m_Usage = USAGE::UNKNOWN;
			STORAGE								m_Storage = STORAGE::UNKNOWN;
			PROPS								m_Props = PROPS::UNKNOWN;
			uint32_t							m_Size = 0;
			CRI_DATA_BUFFER_UPDATE_INFO			m_Update = {};

		}; // struct CRI_DATA_BUFFER_CREATE_INFO
		DECLARE_ENUM_OPERATIONS(CRI_DATA_BUFFER_CREATE_INFO::PROPS)

		

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		/*!	\brief Буфер для данных.
		*/
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		class CCRIDataBuffer {

		//
		public:

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			/*!	\brief Конструктор.

			\param[in] criContext Владеет объектом.
			*/
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			CCRIDataBuffer(CRIContext criContext);

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			/*!	\brief Создать буфер.

			\param[in] createInfo Информация для создания.
			*/
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			void create(const CRI_DATA_BUFFER_CREATE_INFO *createInfo);

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			/*!	\brief Обновить буфер.
			*/
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			void update(const CRI_DATA_BUFFER_UPDATE_INFO *updateInfo);

		// inline
		public:

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			/*!	\brief Получить контекст.
			*/
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			inline CRIContext getContext(void) const;

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			/*!	\brief Получить информацию, по которой был создан буфер.
			*/
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			inline const CRI_DATA_BUFFER_CREATE_INFO& getCreateInfo(void) const;

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			/*!	\brief Получить информацию, по которой был обновлен буфер.
			*/
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			inline CRI_DATA_BUFFER_UPDATE_INFO_ARR& getUpdateInfo(void);

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			/*!	\brief Валидность объекта.

			\return true - объект валидный, false - объект не валидный.
			*/
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			inline bool isValid(void) const;

		// данные
		private:

			CRIContext								m_Context;
			CRI_DATA_BUFFER_CREATE_INFO				m_CreateInfo;		///< информация, по которой был создан буфер
			CRI_DATA_BUFFER_UPDATE_INFO_ARR			m_UpdateInfo;		///< обновление данных
			bool									m_Valid;			///< валидность буфера
			//COMMON::Blob							m_Data1;
			//void*									m_Data;				///< данные
			//size_t									m_Size;				///< размер данных
			
		}; // class CCRIDataBuffer

	} // namespace RENDER

} // namespace FE

#include "CRIDataBuffer.hpp"

#endif // DATA_BUFFER__H